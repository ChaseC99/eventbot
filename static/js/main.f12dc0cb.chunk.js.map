{"version":3,"sources":["AppContext.js","components/navbar/navbar.js","components/tokenInput/tokenInput.js","helpers/slack.js","components/messageInput/messageInput.js","views/sendMessage.js","views/home.js","components/messageTable/messageTable.js","views/scheduleMessage.js","views/editMessage.js","App.js","index.js"],"names":["AppContext","createContext","NavBar","props","onLogout","workspace","useContext","className","team","name","onClick","to","TokenInput","onSubmit","type","SlackClient","webclient","this","slackClient","defaults","headers","a","validateToken","botInfo","userId","user_id","_getLogChannel","logChannel","message","channel","log","chat","postMessage","text","catch","err","console","error","alert","resp","_logMessage","ts","log_ts","update","_updateLogMessage","delete","_deleteLogMessage","post_at","scheduleMessage","scheduled_message_id","deleteScheduledMessage","updated_text","scheduledMessages","list","scheduled_messages","conversations","history","prevMessages","messages","reduce","push","messageDetails","JSON","parse","stringify","message_ts","editMessage","types","channels","val","convo","user","id","auth","test","Promise","reject","token","all","then","result","map","sort","c1","c2","channelDict","info","icon","image_230","MessageInput","submitAction","Object","values","messageTextField","useRef","selectedChannel","event","preventDefault","current","value","ref","defaultValue","i","SendMessage","Home","MessageTable","onUpdateMessage","onDeleteMessage","showIdCol","useState","selectedMessageId","setSelectedMessageId","selectedMessageTextArea","generateRow","selected","readOnly","resetTextArea","oldMessageDetails","updatedText","updateMessage","ScheduleMessage","isLoading","setScheduledMessages","timeInput","useEffect","loadScheduledMessages","getScheduledMessages","formattedMessages","channel_id","updateScheduledMessage","deleteMessage","placeholder","EditMessage","setPrevMessages","loadPrevMessages","loadLog","WebClient","require","App","localStorage","setToken","setIsLoading","setSlackClient","setWorkspace","useHistory","location","useLocation","setItem","login","removeItem","init","loadWorkspace","pathname","saveToken","target","Provider","exact","path","component","render","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f12dc0cb.chunk.js","sourcesContent":["import {createContext} from 'react';\n\nconst AppContext = createContext(null);\n\nexport default AppContext;","import './navbar.css';\n\nimport {NavLink} from 'react-router-dom';\nimport { useContext } from 'react';\nimport AppContext from '../../AppContext';\n\nfunction NavBar(props) {\n  const { onLogout } = props;\n  const { workspace } = useContext(AppContext)\n\n  return (\n    <div className=\"nav-bar\">\n        <h1>EventBot</h1>\n        {workspace && \n            <div>\n                <div className=\"workspace\">\n                    <h3>{workspace.team.name}</h3>\n                    <button onClick={onLogout}>Log Out</button>\n                </div>\n                <ul>\n                    <li><NavLink to='/'>Home</NavLink></li>\n                    <li><NavLink to='/sendMessage'>Send Message</NavLink></li>\n                    <li><NavLink to='/scheduleMessage'>Schedule Message</NavLink></li>\n                    <li><NavLink to='/editMessage'>Edit Message</NavLink></li>\n                </ul>\n            </div>\n        }\n    </div>\n  );\n}\n\nexport default NavBar;\n","import './tokenInput.css';\n\nfunction TokenInput(props) {\n    const {onSubmit} = props\n    return (\n        <div>\n            <h1>Enter Slack Token</h1>\n            <form onSubmit={onSubmit}>\n                <input type=\"password\" />\n                <input type=\"submit\" />\n            </form>\n        </div>\n    );\n}\n\nexport default TokenInput;\n","class SlackClient {\n    constructor(webclient) {\n        this.slackClient = webclient;\n        \n        // Remove User-Agent Header since it causes a CORS error on Safari and Firefox\n        delete this.slackClient[\"axios\"].defaults.headers[\"User-Agent\"];\n    }\n\n    /**\n     * Initializer\n     * This function must be called after constructing a new object.\n     *\n     * Afterwards, the following attributes are loaded on the SlackClient\n     *  userId      - Bot's ID, used to send DMs to the Bot's channel.\n     *  logChannel  - Channel ID for the bot's log \n     */\n    async init() {\n        const botInfo = await this.validateToken();\n        this.userId = botInfo.user_id;\n\n        this.logChannel = await this._getLogChannel();\n    }\n\n    /**\n     * Post Message\n     * \n     * @param {string} message      - text to send\n     * @param {string} channel      - channel id to send to\n     * @param {boolean=true} log    - log the message, so it can be edited or deleted later\n     * @returns the response from the Slack API call\n     */\n    async postMessage(message, channel, log=true) {\n        const resp = await this.slackClient.chat.postMessage({ text: message, channel: channel }).catch((err) => {\n            console.error(err, {channel, message});\n            alert(err + \"\\n\\nSee the full error message in the console.\");\n        })\n\n        // Save the message to it's private DMs\n        if (log) { this._logMessage(resp.ts, resp.channel, resp.message.text); }\n        \n        return resp\n    }\n\n    /**\n     * Edit Message\n     * \n     * @param {string} channel  - channel id of the message\n     * @param {string} ts       - timestamp of the message\n     * @param {string} text     - updated text to send\n     * @param {string} [log_ts] - timestamp of the assosiated log message\n     */\n    async editMessage(channel, ts, text, log_ts) {\n        this.slackClient.chat.update({channel, ts, text})\n        \n        // Update the message history DM to have the new text\n        if (log_ts) { this._updateLogMessage(log_ts, channel, ts, text) }\n    }\n\n    /**\n     * Delete Message\n     * \n     * @param {string} channel  - channel id of the message\n     * @param {string} ts       - timestamp of the message\n     * @param {string} log_ts   - timestamp of the assosiated log message\n     */\n    async deleteMessage(channel, ts, log_ts) {\n        this.slackClient.chat.delete({channel, ts})\n\n        // Delete the message \n        if (log_ts) { await this._deleteLogMessage(log_ts) }\n    }\n\n    /**\n     * Schedule Message\n     * Schedule a message to send at a future time\n     * \n     * @param {string} text     - text to send\n     * @param {string} channel  - channel id to send to\n     * @param {string} post_at  - epoch timestamp to send the message at\n     */\n    async scheduleMessage(text, channel, post_at) {\n        await this.slackClient.chat.scheduleMessage({ channel, text, post_at }).catch((err) => {\n            console.error(err, {channel, text, post_at});\n            alert('Unable to schedule message. Review the error message in the console.');\n        })\n    }\n\n    /**\n     * Delete Scheduled Message\n     * \n     * @param {string} scheduled_message_id - id of the scheduled message\n     * @param {string} channel              - channel id of the message\n     */\n     async deleteScheduledMessage(scheduled_message_id, channel) {\n        await this.slackClient.chat.deleteScheduledMessage({scheduled_message_id, channel}).catch((err) => {\n            console.error(err, {scheduled_message_id, channel});\n            alert('Unable to delete scheduled message. Review the error message in the console.');\n        });\n    }\n\n    /**\n     * Update Scheduled Message\n     * There is no slack api to update a scheduled message. \n     * Instead we must delete the old message a schedule a new one at the same timestamp.\n     * \n     * @param {string} scheduled_message_id - id of the scheduled message\n     * @param {string} channel              - channel id of the message\n     * @param {string} updated_text         - updated text to send\n     * @param {string} post_at              - epoch timestamp to send the message at\n     */\n    async updateScheduledMessage(scheduled_message_id, channel, updated_text, post_at) {\n        await this.deleteScheduledMessage(scheduled_message_id, channel);\n        await this.scheduleMessage(updated_text, channel, post_at);\n    }\n\n    /**\n     * Get Scheduled Messages\n     * \n     * @returns a list of scheduled messages\n     */\n    async getScheduledMessages() {\n        const resp = await this.slackClient.chat.scheduledMessages.list();\n        return resp.scheduled_messages;\n    }\n\n    /**\n     * Load Log\n     *\n     * @returns a list of messages in the log channel\n     */\n    async loadLog() {\n        // All previously sent messages are stored in the bot's DM with itself\n        // Load the messages from that private dm channel\n        const resp = await this.slackClient.conversations.history({channel: this.logChannel});\n        \n        const prevMessages = resp.messages.reduce((messages, message) => {\n                try {\n                    const {text, ts} = message\n                    // For all messages in the channel,\n                    // convert them to JSON and add them to the list \n                    messages.push({messageDetails: JSON.parse(text), log_ts: ts})\n                    return messages\n                } catch {\n                    // If the JSON.parse threw an error, ignore that message\n                    return messages\n                }\n            }, []);\n\n        return prevMessages\n    }\n\n    /**\n     * Log Message\n     * Save the text, timestamp, and channel of a posted message to the bot's log,\n     * in JSON format, so it can be retrieved later\n     * \n     * Format looks like {text: '{text}', ts: '{ts}', channel: '{channel}'}\n     * \n     * @param {string} ts - timestamp of the assosiated log message\n     * @param {string} channel - channel the message was sent in\n     * @param {string} text - text of the message\n     */\n    async _logMessage(ts, channel, text) {\n        const messageDetails = { text, ts, channel }\n\n        // Send a message to it's own user id, containing the message details\n        // It can retrieve this message later by reading the conversation with itself\n        this.postMessage(JSON.stringify(messageDetails), this.userId, false);\n    }\n\n    /**\n     * Update Log Message\n     * Updates the log message assosiated with a real message\n     * This should be called when a message is edited\n     * \n     * @param {string} log_ts - timestamp of the assosiated log message\n     * @param {string} channel - channel the original message was sent in\n     * @param {string} message_ts - timestamp of the original message\n     * @param {string} text - updated text of the message\n     */\n    async _updateLogMessage(log_ts, channel, message_ts, text) {\n        const messageDetails = { channel, ts: message_ts, text }\n        this.editMessage(this.logChannel, log_ts, JSON.stringify(messageDetails))\n    }\n\n    /**\n     * Delete Log Message\n     * Removes message from the log\n     * This should be called when a message is deleted\n     * \n     * @param {string} log_ts - the timestamp of the logged message (not when the actual message was posted)\n     */\n    async _deleteLogMessage(log_ts) {\n        await this.slackClient.chat.delete({channel: this.logChannel, ts: log_ts})\n    }\n\n    /**\n     * Get Log Channel\n     * The log is stored under the Bot's DMs\n     * This fetches the channel id for that\n     * If the conversation doesn't exist yet, this will start it\n     * \n     * @returns the channel id for the log (Bot's own DMs)\n     */\n    async _getLogChannel() {\n        // Get a list of all DM conversations\n        const resp = await this.slackClient.conversations.list({types: \"im\"})\n\n        // Reduce that list to the channel id of the conversation with its own id\n        var logChannel = resp.channels.reduce((val, convo) => {\n            return convo.user === this.userId ? convo.id : val\n        }, null);\n        \n        // If the conversation with itself has not started yet,\n        // Create the conversation and save the channel id\n        if (!logChannel) {\n            logChannel = (await this.postMessage(\"Starting message history\", this.userId, false)).channel;\n        }\n\n        return logChannel\n    }\n\n    /**\n     * Validate Token\n     * Verify that the token is still valid, but sending a test request\n     * \n     * @returns the response from the auth.test api call\n     */\n    async validateToken() {\n        return await this.slackClient.auth.test()\n            .catch(err => {\n                return Promise.reject(`Invalid token: '${this.slackClient.token}'`)\n            })\n    }\n\n    /**\n     * Load Workspace\n     * Fetch the channels and team information for the worksapce\n     * \n     * @returns an object containg the dictionary of channels and team information\n     * {channels: {id: {id, name}}, team: {team info}}\n     */\n    async loadWorkspace() {    \n        const [channels, team] = await Promise.all([\n            // Load channels from Slack Workspace\n            // Set selected channel to the first channel in the list\n            this.slackClient.conversations.list()\n                .then(result => {\n                    const channels = result.channels\n                    .map(channel => ({id: channel.id, name: channel.name}))\n                    .sort((c1, c2) => (c1.name > c2.name) ? 1 : -1)\n                    .reduce((channelDict, channel) => {\n                        channelDict[channel.id] = {...channel};\n                        return channelDict;\n                    }, {});\n                    return {channels};\n                }\n            ),\n\n            // Load team information\n            this.slackClient.team.info()\n                .then(result => {\n                    return {team: {name: result.team.name, icon: result.team.icon.image_230}};\n                }\n            )\n        ])\n        \n        return {...channels, ...team }\n    }\n}\n\nexport default SlackClient;","import './messageInput.css';\n\nimport AppContext from '../../AppContext';\nimport {useRef, useContext} from 'react';\n\nfunction MessageInput(props) {\n  const {submitAction} = props;\n  \n  const { workspace } = useContext(AppContext);\n  const channels = workspace ? Object.values(workspace.channels).map(channel => { \n    return {...channel}\n  }) : null;\n  const messageTextField = useRef(null);\n  const selectedChannel = useRef(null)\n\n  const formSubmitted = event => {\n    event.preventDefault();\n\n    // Get message and channel\n    // Return early if either is blank\n    let message = messageTextField.current.value;\n    let channel = selectedChannel.current.value\n    if (!message) { return }\n\n    // Handle action\n    submitAction(message, channel);\n    \n    // Reset the textarea\n    messageTextField.current.value = '';\n  }\n\n  return (\n    <div className=\"message-sender\">\n        <form onSubmit={formSubmitted}>\n            <textarea type=\"text\" ref={messageTextField} />\n            <div>\n                <select defaultValue={channels ? channels[0].id : ''} ref={selectedChannel}>\n                    {channels && channels.map((channel, i) =>\n                    <option key={i} value={channel.id}>{channel.name}</option>\n                    )}\n                </select>\n                <input type=\"submit\" />\n            </div>\n        </form>\n    </div>\n    \n  );\n}\n\nexport default MessageInput;\n","import MessageInput from '../components/messageInput/messageInput'\nimport AppContext from '../AppContext';\nimport {useContext} from 'react';\n\nfunction SendMessage() {\n    const { slackClient } = useContext(AppContext);\n\n    const sendMessage = (message, channel) => {\n        slackClient.postMessage(message, channel);\n    }\n\n    return (\n        <div>\n            <h1>Send message</h1>\n            <MessageInput submitAction={sendMessage}/>\n        </div>\n    );\n}\n\nexport default SendMessage;\n","function Home() {\n    return (\n        <div>\n            <h1>Welcome to EventBot</h1>\n            <p>Select an action on the left nav bar</p>\n        </div>\n    );\n}\n\nexport default Home;\n","import { useContext, useRef, useState } from 'react';\nimport AppContext from '../../AppContext';\n\nfunction MessageTable(props) {\n    const {messages, onUpdateMessage, onDeleteMessage, showIdCol=false} = props;\n\n    const {workspace} = useContext(AppContext);\n    const [selectedMessageId, setSelectedMessageId] = useState('');\n    const selectedMessageTextArea = useRef(null);\n\n    const editMessage = (id) => {\n        setSelectedMessageId(id)\n    }\n\n    const resetTextArea = (text) => {\n        selectedMessageTextArea.current.value = text; \n        setSelectedMessageId('');\n    }\n\n    const updateMessage = (oldMessageDetails) => {\n        const updatedText = selectedMessageTextArea.current.value;\n        onUpdateMessage(oldMessageDetails, updatedText);\n        setSelectedMessageId('')\n    }\n\n    const generateRow = (message) => {\n        const {\n            messageDetails: {channel, ts, text}, \n            log_ts\n        } = message;\n\n        const selected = selectedMessageId===log_ts;\n\n        return (\n            <tr key={log_ts}>\n                {showIdCol && <td>{log_ts}</td>}\n                <td>#{workspace && workspace.channels[channel].name}</td>\n                <td>{ts}</td>\n                <td>\n                    <textarea \n                        defaultValue={text} \n                        readOnly={!selected} \n                        ref={selected ? selectedMessageTextArea : null}\n                    />\n                </td>\n                <td>\n                    { selected ?\n                        <div>\n                            <button onClick={()=>{resetTextArea(text)}}>Cancel</button>\n                            <button onClick={()=>{updateMessage(message)}}>Update</button>\n                        </div>\n                        :\n                        <button onClick={()=>{editMessage(log_ts)}}>Edit</button>\n                    }\n                </td>\n                <td><button onClick={()=>{onDeleteMessage(message)}}>Delete</button></td>\n            </tr>\n        )\n    }\n\n    return (\n        <table>\n            <tbody>\n                <tr>\n                    {showIdCol && <th>Id</th>}\n                    <th>Channel</th>\n                    <th>Timestamp</th>\n                    <th>Text</th>\n                    <th>Edit</th>\n                    <th>Delete Message</th>\n                </tr>\n                {messages.map(message => generateRow(message)) }\n            </tbody>       \n        </table>\n    )\n}\n\nexport default MessageTable;","import './scheduleMessage.css';\n\nimport MessageInput from '../components/messageInput/messageInput'\nimport { useContext, useEffect, useRef, useState } from 'react';\nimport AppContext from '../AppContext';\nimport MessageTable from '../components/messageTable/messageTable';\n\nfunction ScheduleMessage() {\n    const {slackClient, isLoading} = useContext(AppContext);\n    const [scheduledMessages, setScheduledMessages] = useState([]);\n    const timeInput = useRef(null)\n    \n    useEffect(()=>{\n        if (!isLoading) {loadScheduledMessages()};\n    }, [isLoading])\n\n    const loadScheduledMessages = () => {\n        slackClient.getScheduledMessages().then(messages => {\n            // The list of messages needs to match the structure of messages from slackClient.loadLog()\n            // This map reformats the messages accordingly. The scheduled message id is used as the \"log_ts\".\n            // I realize isn't ideal... maybe we should rework this? \n            const formattedMessages = messages.map(message => {\n                return {\n                    messageDetails: {\n                        channel: message.channel_id,\n                        ts: message.post_at,\n                        text: message.text\n                    },\n                    log_ts: message.id\n                }\n            });\n\n            setScheduledMessages(formattedMessages);\n        })\n    }\n\n    const scheduleMessage = async (message, channel) => {\n        await slackClient.scheduleMessage(message, channel, timeInput.current.value);\n        loadScheduledMessages();\n    }\n\n    const updateMessage = async (oldMessageDetails, updatedText) => {\n        const {messageDetails: {channel, ts}, log_ts } = oldMessageDetails;\n        await slackClient.updateScheduledMessage(log_ts, channel, updatedText, ts);\n    }\n\n    const deleteMessage = async (oldMessageDetails) => {\n        const {messageDetails: {channel}, log_ts } = oldMessageDetails;\n        await slackClient.deleteScheduledMessage(log_ts, channel);\n        loadScheduledMessages();\n    }\n\n    return (\n        <div>\n            <h1>Schedule message</h1>\n            <input ref={timeInput} placeholder=\"Epoch time\"/>\n            <MessageInput submitAction={scheduleMessage} />\n            <h3>Scheduled Messages</h3>\n            <MessageTable\n                messages={scheduledMessages}\n                onUpdateMessage={updateMessage}\n                onDeleteMessage={deleteMessage}\n                showIdCol={true}\n            />\n        </div>\n    );\n}\n\nexport default ScheduleMessage;\n","import './scheduleMessage.css';\n\nimport MessageTable from '../components/messageTable/messageTable';\nimport { useContext, useEffect, useState } from 'react';\nimport AppContext from '../AppContext';\n\nfunction EditMessage() {\n    const {slackClient, isLoading} = useContext(AppContext);\n    const [prevMessages, setPrevMessages] = useState([]);\n    \n    useEffect(()=>{\n        if (!isLoading) {loadPrevMessages()};\n    }, [isLoading])\n\n    const loadPrevMessages = () => {\n        slackClient.loadLog().then(messages => {\n            setPrevMessages(messages)\n        })\n    }\n\n    const updateMessage = async (oldMessageDetails, updatedText) => {\n        const {messageDetails: {channel, ts}, log_ts } = oldMessageDetails;\n        await slackClient.editMessage(channel, ts, updatedText, log_ts);\n        loadPrevMessages();\n    }\n\n    const deleteMessage = async (oldMessageDetails) => {\n        const {messageDetails: {channel, ts}, log_ts } = oldMessageDetails;\n        await slackClient.deleteMessage(channel, ts, log_ts);\n        loadPrevMessages();\n    }\n\n    return (\n        <div>\n            <h1>Edit message</h1>\n            <p>Select a message below to edit or delete.</p>\n            <h3>Previous Messages</h3>\n            <MessageTable \n                messages={prevMessages}\n                onUpdateMessage={updateMessage}\n                onDeleteMessage={deleteMessage}\n            />\n            {/* <h3>Manual Edit</h3>\n            <p>If the message you want to edit is missing from the list above, you can also manually enter the message below.</p>\n            <p><em>Note: You can only edit messages sent by the bot</em></p>\n            <input placeholder=\"Timestamp\"/>\n            <MessageInput submitAction={scheduleMessage} /> */}\n        </div>\n    );\n}\n\nexport default EditMessage;\n","import './App.css';\nimport {\n  Route,\n  useHistory,\n  useLocation\n} from 'react-router-dom';\nimport {useEffect, useState} from 'react';\nimport NavBar from './components/navbar/navbar';\nimport AppContext from './AppContext';\nimport TokenInput from './components/tokenInput/tokenInput';\nimport SlackClient from './helpers/slack';\nimport SendMessage from './views/sendMessage';\nimport Home from './views/home';\nimport ScheduleMessage from './views/scheduleMessage';\nimport EditMessage from './views/editMessage';\n\nconst { WebClient } = require('@slack/web-api');\n\nfunction App() {\n  const [token, setToken] = useState(localStorage['slackToken']);\n  const [isLoading, setIsLoading] = useState(true);\n  const [slackClient, setSlackClient] = useState();\n  const [workspace, setWorkspace] = useState(); \n  const history = useHistory();\n  const location = useLocation();\n  \n  useEffect(() => {\n    if (token) {\n      // Save Slack token to local storage for future use\n      localStorage.setItem('slackToken', token);\n\n      // Login with new token\n      login()\n    } else {\n      localStorage.removeItem('slackToken');\n      history.push(\"/login\");\n    }\n  }, [token])\n\n  // Logout\n  // Clear token and workspace information\n  const logout = () => {\n    setToken();\n    setWorkspace();\n  }\n\n  // Login\n  // Validate token and load workspace information\n  // If token is invalid, an alert will be shown\n  const login = async () => {\n    try {\n      // Create WebClient to interface with Slack API\n      const slackClient = new SlackClient(new WebClient(token)); \n      await slackClient.init()\n\n      // Update the states\n      setSlackClient(slackClient)\n      setWorkspace(await slackClient.loadWorkspace());\n      setIsLoading(false);\n\n      // If on the login page, redirect home\n      if (location.pathname === '/login') {\n        history.push(\"/\")\n      }\n    } catch(err) {\n      // Token was invalid, reset and display alert\n      setToken()\n      alert(err)\n    }\n  }\n\n  const saveToken = event => {\n    event.preventDefault();\n    setToken(event.target[0].value);\n    event.target[0].value = '';\n  }\n\n  return (\n    <div className=\"App\">\n      <AppContext.Provider value={{slackClient, workspace, isLoading}}>\n        <NavBar onLogout={logout}/>\n        <div className=\"content\">\n          <Route exact path=\"/\" component={Home} />\n          <Route path=\"/sendMessage\" component={SendMessage} />\n          <Route path=\"/scheduleMessage\" component={ScheduleMessage} />\n          <Route path=\"/editMessage\" component={EditMessage} />\n          <Route path=\"/login\" render={() => <TokenInput onSubmit={saveToken} />} />\n        </div>\n      </AppContext.Provider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { HashRouter } from 'react-router-dom';\n\nReactDOM.render(\n  <React.StrictMode>\n    <HashRouter>\n      <App />\n    </HashRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}